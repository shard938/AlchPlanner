<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Cubic Bezier Generator</title>
<style>
  body {
    background-color: #2c2c2c;
    margin: 0;
  }
  canvas {
    border: none;
    background-color: #2c2c2c;
  }
</style>
</head>
<body>
<div style="display: flex; align-items: flex-start; height: 100vh;">
  <div id="sidebar" style="position: absolute; top: 50px; left: 130px; width: 250px; background-color: #2c2c2c; color: white; padding: 10px; font-family: sans-serif;">
    <div style="display: flex; justify-content: space-between; align-items: baseline;">
      <span style="font-weight: bold;">Paths</span>
      <div style="display: flex; gap: 10px; align-items: baseline;">
        <button id="addPath" style="background: none; border: none; color: white; font-size: 18px; cursor: pointer;">+</button>
        <button id="togglePaths" style="background: none; border: none; color: white; font-size: 14px; cursor: pointer;">â‡µ</button>
      </div>
    </div>
    <ul id="pathList" style="list-style: none; padding-left: 10px;">
      <!-- Path items will be inserted here -->
    </ul>
  </div>
<canvas id="bezierCanvas" width="1520" height="790"></canvas>
<script>
const canvas = document.getElementById('bezierCanvas');
const ctx = canvas.getContext('2d');
let curves = [];
let history = [];
let redoStack = [];
let drag = { curveIdx: null, pointIdx: null };
let selected = { curveIdx: null, pointIdx: null };

const bg = new Image();
bg.src = 'V5RC-HighStakes-Skills-TileColor66_71-2000x2000.png';
bg.onload = () => draw();

let isDragging = false;
let justDragged = false;

canvas.addEventListener('click', e => {
  const rect = canvas.getBoundingClientRect();
  const baseX = e.clientX - rect.left;
  const baseY = e.clientY - rect.top;

  // Check if clicking a control point to select
  for (let i = 0; i < curves.length; i++) {
    for (let j = 0; j < 4; j++) {
      if (Math.hypot(curves[i][j].x - baseX, curves[i][j].y - baseY) < 10) {
        selected = { curveIdx: i, pointIdx: j };
        draw();
        return;
      }
    }
  }

  if (isDragging || justDragged) {
    justDragged = false;
    return;
  }

  const boxX = 450, boxY = 20, boxW = 650, boxH = 650;
  if (baseX < boxX || baseX > boxX + boxW || baseY < boxY || baseY > boxY + boxH) return;

  const centerX = boxX + boxW / 2;
  const centerY = boxY + boxH / 2;
  const newCurve = [
    { x: baseX, y: baseY },
    { x: (baseX + centerX) / 2, y: baseY - 50 },
    { x: (baseX + centerX) / 2, y: centerY + 50 },
    { x: centerX, y: centerY }
  ];
  history.push(curves.map(c => c.map(p => ({...p}))));
  curves.push(newCurve);
  draw();
});

canvas.addEventListener('mousedown', e => {
  history.push(curves.map(c => c.map(p => ({ ...p }))));
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  for (let i = 0; i < curves.length; i++) {
    for (let j = 0; j < 4; j++) {
      if (Math.hypot(curves[i][j].x - x, curves[i][j].y - y) < 10) {
        drag = { curveIdx: i, pointIdx: j };
        selected = { curveIdx: i, pointIdx: j };
        isDragging = true;
        return;
      }
    }
  }
});

canvas.addEventListener('mousemove', e => {
  if (drag.curveIdx === null) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const boxX = 450, boxY = 20, boxW = 650, boxH = 650;
  if (x < boxX || x > boxX + boxW || y < boxY || y > boxY + boxH) return;

  curves[drag.curveIdx][drag.pointIdx] = { x, y };
  draw();
});

canvas.addEventListener('mouseup', () => {
  draw();
  selected = { curveIdx: null, pointIdx: null };
  if (drag.curveIdx !== null) {
    justDragged = true;
    setTimeout(() => justDragged = false, 0);
  }
  drag = { curveIdx: null, pointIdx: null };
  isDragging = false;
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  for (let i = 0; i < curves.length; i++) {
    const curve = curves[i];
    const distance = pointToBezierDistance(x, y, curve);
    if (distance < 10) {
      history.push(curves.map(c => c.map(p => ({...p}))));
      curves.splice(i, 1);
      draw();
      return;
    }
    for (let j = 0; j < 4; j++) {
      if (Math.hypot(curve[j].x - x, curve[j].y - y) < 10) {
        curves.splice(i, 1);
        draw();
        return;
      }
    }
  }
});

function pointToBezierDistance(x, y, [p0, p1, p2, p3]) {
  let minDist = Infinity;
  for (let t = 0; t <= 1; t += 0.01) {
    const cx = bezierPoint(p0.x, p1.x, p2.x, p3.x, t);
    const cy = bezierPoint(p0.y, p1.y, p2.y, p3.y, t);
    const d = Math.hypot(cx - x, cy - y);
    if (d < minDist) minDist = d;
  }
  return minDist;
}

function bezierPoint(p0, p1, p2, p3, t) {
  return (
    (1 - t) ** 3 * p0 +
    3 * (1 - t) ** 2 * t * p1 +
    3 * (1 - t) * t ** 2 * p2 +
    t ** 3 * p3
  );
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const boxX = 450, boxY = 20, boxW = 650, boxH = 650;
  const frameThickness = 10;
  ctx.fillStyle = '#111059';
  ctx.fillRect(boxX - frameThickness, boxY - frameThickness, boxW + 2 * frameThickness, frameThickness);
  ctx.fillRect(boxX - frameThickness, boxY + boxH, boxW + 2 * frameThickness, frameThickness);
  ctx.fillRect(boxX - frameThickness, boxY, frameThickness, boxH);
  ctx.fillRect(boxX + boxW, boxY, frameThickness, boxH);
  ctx.drawImage(bg, boxX, boxY, boxW, boxH);

  for (let i = 0; i < curves.length; i++) {
    const curve = curves[i];
    if (curve.length < 4) continue;

    ctx.beginPath();
    ctx.moveTo(curve[0].x, curve[0].y);
    ctx.lineTo(curve[1].x, curve[1].y);
    ctx.moveTo(curve[2].x, curve[2].y);
    ctx.lineTo(curve[3].x, curve[3].y);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(curve[0].x, curve[0].y);
    ctx.bezierCurveTo(curve[1].x, curve[1].y, curve[2].x, curve[2].y, curve[3].x, curve[3].y);
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.stroke();

    for (let j = 0; j < curve.length; j++) {
      const p = curve[j];
      ctx.beginPath();
      ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
      if (selected.curveIdx === i && selected.pointIdx === j) {
        ctx.fillStyle = 'rgba(255, 255, 0, 1)';
      } else {
        ctx.fillStyle = 'rgba(128, 0, 128, 0.85)';
      }
      ctx.fill();
    }
  }
}
document.addEventListener('keydown', e => {
  if (e.ctrlKey && e.key === 'z') {
    if (history.length > 0) {
      redoStack.push(curves.map(c => c.map(p => ({ ...p }))));
      curves = history.pop();
      draw();
    }
  } else if (e.ctrlKey && (e.key === 'y' || e.key === 'Y')) {
    if (redoStack.length > 0) {
      history.push(curves.map(c => c.map(p => ({ ...p }))));
      curves = redoStack.pop();
      draw();
    }
  }
});
</script>
</body>
</html>
